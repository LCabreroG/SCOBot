<!DOCTYPE html>
<html>
	<head>
		<title>SCORM API ReadMe</title>
		
		<style type="text/css">
			* {margin: 0px; padding: 0px; -webkit-touch-callout: none; -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-select: none; -webkit-font-smoothing:antialiased; -webkit-text-size-adjust: none;}
			img {border-style: none;}
			html, body{width: 100%; height: 100%;}
			body{font-family: Lucida Grande, Arial, Verdana; font-size: 13px; color: #f4f4f4;  text-shadow: rgba(0,0,0,.1) 2px 2px 2px; min-width: 955px; min-height: 600px;}
			a:link{color: #333;}
			a:visited{color: #000;}
			a:hover{color: #333;}
			a:active{color: #ff8d8a;}
			#contact{position: absolute; top: 15px; right: 20px;}
			.blackgrad{
				background: -webkit-gradient(linear, left top, left bottom, from(#000), to(#3a3a3a)); 
				background: -moz-linear-gradient(top,  #000,  #3a3a3a); 
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#000000', endColorstr='#3a3a3a');
			}
			.bluegrad{
				background: -webkit-gradient(linear, left top, left bottom, from(#0f71b1), to(#17567f)); 
				background: -moz-linear-gradient(top,  #0f71b1,  #17567f); 
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#0f71b1', endColorstr='#17567f'); background-color: #17567f;
			}
			.whitegrad{
				background: -webkit-gradient(linear, left top, left bottom, from(#e9e8e8), to(#eff1ee)); 
				background: -moz-linear-gradient(top,  #e9e8e8,  #eff1ee); 
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#e9e8e8', endColorstr='#eff1ee'); background-color: #eff1ee;
			}
			.graygrad{
				background: -webkit-gradient(linear, 0% 0, 0% 100%, from(#9AA7B2), color-stop(0.02, #647482), to(#3E4851)); 
				background: -moz-linear-gradient(top,  #9AA7B2, #647482, #3E4851); 
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#9AA7B2', endColorstr='#3E4851'); 
				background-color: #3E4851;
			}
			.orangegrad{
				background: -webkit-gradient(linear, left top, left bottom, from(#e2bf3d), to(#ca7c34)); 
				background: -moz-linear-gradient(top,  #e2bf3d,  #ca7c34); 
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#e2bf3d', endColorstr='#ca7c34'); 
				background-color: #ca7c34;
				color: #333;
			}
			.greengrad{
				background: -webkit-gradient(linear, left top, left bottom, from(#e6f8e7), to(#cbe9cc)); 
				background: -moz-linear-gradient(top,  #e6f8e7,  #cbe9cc); 
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#e6f8e7', endColorstr='#cbe9cc'); 
				background-color: #cbe9cc;
			}
			#doc{position: relative; padding: 10px; height: auto;}
			#doc p, pre{margin-left: 20px; padding: 3px;}
			#page {padding: 10px; color: #333;}
			h1{color: #198945; padding: 5px;}
			h2{color: #76762f; padding: 10px 5px; font-size: 16px;}
			h3{color: #755f28; padding: 5px; font-size: 14px; margin-left: 18px;}
			h4{color: #817d17; padding: 5px; font-size: 14px; margin-left: 20px;}
			h5{color: #815501; padding: 5px; font-size: 16px; margin-left: 20px;}
			pre{padding: 10px; margin: 0 25px 10px 25px; border: 1px solid #CCC; color: #CCC;}
			span.note{font-size: 11px; color: #000; font-style: italic;}
			.rounded{
				-webkit-border-radius: 8px; border-radius: 8px; -moz-border-radius: 8px; 
				-webkit-box-shadow: rgba(0,0,0,.3) 0px 5px 5px; -moz-box-shadow: rgba(0,0,0,.3) 0px 5px 5px;
			}
			.optional{padding: 10px 10px 0 0;}
			.numlist{margin-left: 60px; margin-right: 30px; color: #000;}
			.numlist li{padding: 2px 5px 2px 5px; font-size: 11px;}
			
		</style>
	</head>
	<body class="orangegrad">
		<div id="doc" class="bluegrad">
			<div id="page" class="whitegrad rounded">
			<div id="contact"><a href="mailto:mark@cybercussion.com">mark@cybercussion.com</a></div>
			<h1>SCORM_API Documentation:</h1>
			<p>Hi, this can get overwhelming, but speaking from experience it will sink in after a year or so, so don't be too hard on yourself.  I made this firstly to solve my own morbid curiosity, and validate I didn't lose my mind somewhere along the way.  I know the core desire is to get and save data, and everything in-between is just obstacles in your way.  You could run out and use a few 3rd party API's and I've done that myself.  But, I always found myself either shocked at how large they were, mad that they didn't include things everyone commonly runs into or just banging my head into a wall trying to figure out how something translated into SCORM (geek) speak.  This is not anything official, its like a pure "army of one" approach.</p><p>If you've ever worked with someones "plug-in" or library, commonly you get a set of files, some working examples, and some documentation.  SCORM wasn't really like that, and you have to dig around the web by way of Google to find anything, and its most commonly based on a rather large white-paper.  You'll then find out there are like 5 other people doing it and start to wonder why your doing this to yourself.  This is like everything complex in life, and shouldn't be mocked simply because its not understood.  There is a lot of thought that went into this, but it is dreadfully out dated.  This is not the architects fault, technology has advanced a bit in the last 6 years.  Don't forget this standard had to survive a few browser wars and now the onslaught of mobile devices.  If you were to consider SCORM a "Ping", its taken years to get the "Pong".</p>
			<p>The intent of this API <span class="note">(Application Programming Interface)</span> is to serve as a consolidated script to interface with an LMS <span class="note">(Learning Management Server)</span> using SCORM 1.2 or 2004 <span class="note">(Shareable Content Object Reference Model)</span>.  Beware, there are differences between these two standards.  This API attempts to mitigate that by converting calls made for SCORM 2004, back to SCORM 1.2 in the event the LMS doesn't support SCORM 2004.  This should save you some headache adjusting all your content specific calls to SCORM 1.2.  This "adaptor" is not a 100% safe solution however.  Differences can be as simple as where the data is stored, or limitations on character limits you simply <u>must</u> be aware of.</p>
			<p>SCORM stores all its data in a <code>cmi</code> <span class="note">(computer managed instruction)</span> object.  Thru use of verbose strings, you can <code>get</code> and <code>set</code> against the LMS API.  As mentioned, the standard changed between SCORM 1.2 and 2004.  You could consider SCORM 2004 as the "Windows XP Professional" release.  Its old, it irritates, and we're in a bit of a bind now since its been 6 years with only some hints that something new is coming.  I've been highly critical that they don't allow the <code>cmi</code> object to scale.  Arbitrary character limits, etc... Others, irritated its restricted purely to JavaScript, and offers no external access to say native iOS apps or video games.</p><p>However, here is the kicker.  There is nothing stopping a LMS from providing a public service for this stuff.  You could make it pass a JSON string back and forth, so it could natively be digested by both the content and the LMS.  It's well within their capabilities, but its the communication is defined thru JavaScript, and the LMS manages/enforces the standard.  But I digress.</p>
			<p>An example in SCORM 1.2 you get <b>255</b> characters for '<code>cmi.core.location</code>'.  However, in SCORM 2004 you get <b>1000</b> characters in '<code>cmi.location</code>'.  This means you must be aware if your SCO <span class="note">(Shareable Content Object)</span> writes excessive amounts of data.  This can cause you to 'breakup' your SCO's into less pages, or force you to locate a LMS that supports SCORM 2004.  It can even leave you locating proprietary ways to store the information, making your content less portable between LMS's.  Both this API, and the LMS (most anyway) have error handling built in, but when you exceed these limits errors will be thrown <span class="note">(in some cases silently to the student)</span>, and in most cases those calls will be ignored, thus losing data during that session.</p>
			
			<h2>The Standard(s)</h2>
			<p>If you're completely unaware of SCORM 1.2, or 2004 - I'd recommend checking out the following two resources:</p>
			<p><a href="http://sites.google.com/site/scormposters/scorm-poster-download" target="_blank" title="SCORM Poster" alt="SCORM Poster">SCORM Visual Poster</a><br />
			<a href="http://scorm.com/scorm-explained/scorm-resources/reference-poster/" target="_blank" title="Scorm Poster" alt="SCORM Poster">SCORM Cheat sheet Poster</a></p>
			<p><span class="note">If your already a SCORM Ninja, move along, nothing to see.</span></p>
			<p>This is typically a shock to the system.  I'll allow you a moment to pick up your eyes.  AAAAaand were back.  Ok, the best way I can recommend approaching this is understanding what you have available to you, and what you actually want to store.  Keep one eye on the limitations between the standards, and one eye on the Instructional Content and how much data its generating.  Keep in mind you don't have to store the kitchen sink, just store the index or reference to it. Some times you have to though, and Suspend Data is a great place (one of the only) to really get away with that.</p>
			<p>One way to think about this is the LMS holds the data model shown below.  Its like a massive form the learner doesn't even know they are filling in by interacting with your content.  As the content gets/sets values against it the data is populated and stored in the LMS.  It's sometimes difficult to illustrate whats really happening, but I'll try to break it down in a different way than its been described above.</p><p>When you launch an LMS, and you get to the part where your going to dive into a Lesson or launch some content, it makes a call to the Server to get the data for that SCO.  That can be done either as a whole entirely new page, or a Web 2.0 practice would be to make a Ajax request.  Once that is fulfilled, then it launches the content.  Because your content tends to be launched in a window, a frameset or a IFRAME (or some hybrid or a mix), this actually means all the data is directly available on your device/browser at runtime.  There are no asynchronous requests that occur at this point.  Everything is directly pulling thru the API provided by the LMS to access the data.  It's like a pseudo data cop enforcing read, write, character restrictions among others.  Keep in mind this is all JavaScript &lt;-&gt; Javascript communication occurring directly on your client.  No server side communication is taking place until you Commit.</p>
			<h3>Translating the Geek</h3>
			<p>The core of SCORM is Initialize, Get/Set Values, Commit and Terminate.</p><p>Common things you most like will do:</p>
			<p><b>Mode:</b> <code>cmi.mode</code> - "normal", "review" or "browse".  Its important to handle this as SCORM will only commit information in normal mode.  You may want to disable elements, fields or interactivity in review mode, so the student doesn't think they can actually do anything in this mode.</p>
			<p><b>Bookmarking:</b> <code>cmi.location</code> - You get 1000 characters (2004) or 255 in (1.2).  This could be as simple as the page they left off on, or a JSON String (as an example) with richer information.</p>
			<p><b>Suspending:</b> <code>cmi.suspend_data</code> - You get 64000 characters (2004) or 4096 in (1.2).  This allows you to store a JSON String (as an example) that has all the page(s) data organized within so when it re-launches you can put everything back the way it was when the student left.</p>
			<p><b>Scoring, Status, Progress</b> - Commonly you'll set the raw, min and max score.  You'll need to also set completion status, success status at minimum to reflect a passed SCO, lesson or course on the LMS.</p>
			<p><b>Committing:</b> - You may feel the need to store the students data between pages incase the power goes out or some other server related issue.  This is commonly handled automatically on <code>terminate</code>, however you can call <code>commit</code> as often as you like.</p>
			<p><b>Have stronger tastes?</b> - Quizes/Tests are important to actually log appropriately.  These are more commonly called "interactions".  This is where setting objectives and interactions will come into play.  This is also an area that gets heavily complicated because you need to choose between Journaling or handling states.  But hats the difference?</p>
			<p>With Journaling, you're going to add a new interaction each time, creating a history of interactions for any number of identifiers.  This is a great way to see where a student is having trouble, or how many times they looked at something.</p>
			<p>With states, your going to look up the interaction by identifier and update it, thus losing any historical references.</p>
			<p>How to choose between these, may require to you look at the LMS your deploying on to find out if there is really any value-add to historial information like this.  If they offer no port for viewing it, you may be doing it in vain.</p>
			<br />
			<b>Hell hath no fury like a content object SCORMed</b>
			<p>I understand that there are wavering levels of attention span when it comes to the visual perception of how hard or easy something is.  This is why we offload our taxes to some guy/gal right?  Trying to turn all this into english (or your native language), and having something that can evenly distribute or consume whats happening would seem much smarter than plugging it all in by hand right?</p>
			<p>This is fundamentally the part thats been missing, and the part left in the 'eye of the beholder'.  They gave you this rich object to populate, and all these rules, but left you holding the bill.  I am all to familiar wit the perpetual "oh, we won't do that its too complicated", much to the extreme where you have to wonder why they aren't just using Powerpoint!?!  This is where you want to take a deep breath, and plan what your goals are, what the LMS supports and maybe whats for dinner after you read this.</p>
			<br />
			<b>You have been oriented</b>
			<p>If you are unfamiliar with JSON, and your use to writing code, you may find this easy to use.  If not, this may seem completely alien to you.  It gives you the ability to encode or decode a Object to a String or a String to a Object.  This enables you to work directly in your programming language using your native objects, and then via string send them to another computer.  This enforces Strings, Numbers, Booleans, Arrays, Objects and is parsed 100x faster than XML in the browser. Unfortunately, everything in SCORM is a string (haha).</p><p>JSON from what I understand has been around since 2001, but seems to have gained more momentum post 2005.  I don't even consider XML anymore after using it, though I can understand the comfort zone some feel when they crack open a <code>&lt;node&gt;</code>.  I ignored JSON myself for about 2 years before giving it a fair shake.</p>
			<p>Here is a example of JSON Markup displaying the CMI <span class="note">(computer managed instruction)</span>, ADL <span class="note">(Advanced Distributed Learning)</span> and SSP <span class="note">(Shared State Persistence)</span> objects <span class="note">(everything in scorm is a string)</span>:</p>
			<pre class="blackgrad rounded"><code>{
    "cmi": {
        "_version": "1.0",
        "comments_from_learner": {
            "_children": "comment,location,timestamp",
            "_count": "0"
        },
        "comments_from_lms": {
            "_children": "comment,location,timestamp",
            "_count": "0"
        },
        "completion_status": "incomplete",
        "completion_threshold": "0.7",
        "credit": "credit",
        "entry": "ab-intio",
        "exit": "normal",
        "interactions": {
            "_children": "id,type,objectives,timestamp,correct_responses,weighting,learner_response,result,latency,description",
            "_count": "0"
        },
        "launch_data": "",
        "learner_id": "100",
        "learner_name": "Students Name",
        "learner_preference": {
            "_children": "audio_level,language,delivery_speed,audio_captioning",
            "audio_level": "",
            "language": "",
            "delivery_speed": "",
            "audio_captioning": ""
        },
        "location": "2",
        "max_time_allowed": "",
        "mode": "normal",
        "objectives": {
            "_children": "id,score,success_status,completion_status,description",
            "_count": "0"
        },
        "progress_measure": "",
        "scaled_passing_score": "",
        "score": {
            "_children": "scaled,raw,min,max",
            "scaled": "",
            "raw": "",
            "min": "",
            "max": ""
        },
        "session_time": "PT1M19.78S",
        "success_status": "",
        "suspend_data": "",
        "time_limit_action": "",
        "total_time": "PT8H55M52.89S"
    },
    "adl": {
        "nav": {
            "request": "",
            "request_valid": {
                "continue": "",
                "previous": "",
                "choice": ""
            }
        }
    },
    "ssp": {
        "allocate": "",
        "_count": "0"
    }
}</code></pre>
			<p>Its important to note this object sits in the API_1484_11 at the LMS Level.  As you make requests to say <code>scorm.getvalue('cmi.learner_name');</code> the LMS will return in a synchronous fashion the name of the learner.</p><p>Dealing with these as strings is just apart of the fun.  If we could of just made a reference to the CMI Object at the LMS Level and ignored all the "rules" about read/write and character limits then you could of done something like <code>var learner_name = LMS.cmi.learner_name;</code> and of been done with it.</p><p>The LMS is required to have this data object loaded before it loads the SCO.  As the learner enters data into a SCO, these objects are populated with there data, so they can be reviewed, suspended or submitted.</p>
			<h2>Developer: Getting Started</h2>
			<p>You'll need to install the script, then append it to your <code>html</code> document.</p>
			<pre class="blackgrad rounded"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/scorm/SCORM_API.js&quot;&gt;&lt;/script&gt;</code></pre>
			
			<p>Next you'll want to instantiate the <b>SCORM_API</b> object, possibly overriding default values...<br /><span class="note">Note: Please read on, if you desire a full event driven implementation below...</span></p>
			<pre class="blackgrad rounded"><code>&lt;script type=&quot;text/javascript&quot;&gt;
	var scorm = new SCORM_API({debug: true});
&lt;/script&gt;</code></pre>
			<p>At this moment the object with self-initialize and begin to locate the LMS API for either SCORM 1.2 or 2004.</p>
			<h3>Other overriding values:</h3>
			<p><code>debug {Boolean}</code>: Defaults to <code>false</code>, if set <code>true</code> it will send messages to the console.</p>
			<p><code>throw_alerts {Boolean}</code>: Defaults to <code>true</code>, and will pop alert boxes when error or warnings occur.</p>
			<p><code>exit_type {String}</code>: Defaults to <code>"suspend"</code>, you could also set it to <code>"finish"</code>.  Default exit behavior for the SCO. <br /><span class="note">Note: This will be set automagically by <code>scorm.terminate();</code></span></p>
			<p><code>completion_status {String}</code>: Defaults to <code>"unknown"</code>, you could also set it to <code>"not attempted", "incomplete", or "passed"</code>.  Default status behavior for the SCO.<br /><span class="note">Note: This will be set automagically by <code>scorm.initialize();</code></span></p>
			<h3>Handling Browser Events (if you use SCOBot skip this):</h3>
			<p>If you need away to auto <code>initialize</code> and <code>terminate</code>, I recommend pointing native browser <code>onload, onunload,</code> and <code>onbeforeunload</code> events to your own internal <code>init</code> and <code>exit</code> methods.  I include something like this is a events.js file.</p>
			<p>Due to some known mozilla <code>onunload</code> event issues with popup windows and <code>IFRAME</code>'s, I recommend using the following:</p>
			<pre class="blackgrad rounded"><code>/*global $, JQuery, player, SCORM_API, SCOBOT */
// Define JSLint global values above this line

// This will handle the Initalization (load) and Exit (unload) of the SCO
var isExit       = false, 
	lmsconnected = false,
	scorm        = new SCORM_API({debug: true});
	
function initSCO() {
	lmsconnected = scorm.initialize();
	scorm.debug("SCO Loaded from window.onload " + lmsconnected, 4);
	if(lmsconnected) {
		player.init(); // Things you'd do like getting mode, suspend data
	}
}
function exitSCO() {
	if(!isExit) {
		isExit = true;
		player.exit();
		scorm.debug("SCO is done unloading.", 4);
	}
}
/**
* window.top used since there was a exit issue in older mozilla (FF/Safari) browsers.
* This occured in Popup windows and IFRAMEs.  window.top covers itself or a parent(s).
* Later I found out that it seemed to be something with JQuery, and reverted it after 1.7+.
* This will listen when and if the learner closes the browser, and hopefully gives the 
* content time to wrap up its business.
*/
$(window).bind('load', initSCO);
$(window).bind('unload', exitSCO);
$(window).bind('beforeunload', exitSCO);
</code>
</pre>
			<div class="optional greengrad rounded">
				<h5>SCOBot (<i>optional </i>):</h5>
				<p>If you don't want to long hand write all the proper calls and sequences associated with SCORM, SCOBOT is the droid you were looking for.  SCORM sometimes makes 4 or 5 calls just firing up or exiting.  This won't take all the burn out of it, but it will help.  At minimum educate.  All the subtle things you'd do at low levels of your SCO would need to be written anyway, so this in a way is much of all that rolled up at a higher level.  You implementations may vary, which is why I leave this open to being edited or altered at your discretion.</p>
				<p>You'll need to install another script in your <code>html</code>, and this one is optional...</p>
				<pre class="blackgrad rounded"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/scorm/SCOBOT.js&quot;&gt;&lt;/script&gt;</code></pre>
				
				<p>SCOBOT takes care of Start, Finish among others.  It can be made more or less intelligent based on your needs.</p>
				<p>I recommend implementing it after you initialize your player.</p>
				<pre class="blackgrad rounded"><code>var SB = new SCOBOT({
	interactions_mode: 'state' // or journaled
});
</code></pre>
				
				<p>I'm starting off with the easy stuff, then we'll dig in a bit into some long hand calls.</p>
				<p>If you choose to use SCOBot it will override work we talked about above.  By default initSCO and exitSCO are built in and SCOBot will fire trigger handlers so a external player can listen for these to kick of there methods.  Here are the events you can listen to for this:</p>
				<pre class="blackgrad rounded">
					<code>
$(SB).on('load', function(e) {
	player = new Player(); // or player.init();  You customize this!
	return false;
});


$(SB).on('unload', function(e) {
	player.exit();         // You customize this!
	return false;
});
					</code>
				</pre>
				<h4>SB.start(); (This is default functionality)</h4>
				<p>Because you used 'events.js' above, the SCO is already 'initialized' via the line "<code>lmsconnected = scorm.initialize();</code>".  If you didn't use that, I'd recommend doing something like it (<code>onload</code>) or modifying the method to do it.</p><p>Whew! Now that the possibly awkward moment is over, start is going to do the following for you:</p>
				<ol class="numlist whitegrad rounded">
					<li><code>scorm.getvalue('cmi.mode');              // Learners Mode: browse, review, normal</code></li>
					<li><code>scorm.getvalue('cmi.entry');             // Learners Entry: ab-initio, resume, ""</code></li>
					<li><code>scorm.getvalue('cmi.launch_data');       // Learners Launch Data</code></li>
					<li><code>scorm.getvalue('cmi.location');          // Learners Bookmark</code></li>
					<li><code>scorm.getvalue('cmi.suspend_data');      // Learners Suspended Data from a prior visit</code></li>
					<li><code>scorm.getvalue('cmi.completion_status'); // Learners Completion Status: completed, incomplete, not attempted or unknown</code></li>
					<li><code>scorm.getvalue('cmi.success_status');    // Learners Success Status: passed, failed or unknown</code></li>
				</ol>
				<br />
				<h4>SB.getBookmark();</h4>
				<p>This will return the learners bookmark aka <code>cmi.location</code></p>
				<ol class="numlist whitegrad rounded">
					<li><code>scorm.getvalue('cmi.location');  // Learners Bookmark: You can retrieve roughly 1000 characters here</code></li>
				</ol>
				<br />
				<h4>SB.getBookmark('value');</h4>
				<p>This will set the learners bookmark aka <code>cmi.location</code></p>
				<ol class="numlist whitegrad rounded">
					<li><code>scorm.setvalue('cmi.location', '3');  // Learners Bookmark: You can place roughly 1000 characters here.</code></li>
				</ol>
				<br />
				<h4>SB.commit();</h4>
				<p>You'd want to tie in a commit between pages maybe, or if you present a save button to the student.</p>
				<ol class="numlist whitegrad rounded">
					<li><code>scorm.commit();</code></li>
				</ol>
				<br />
				<p>The values above requested from SCORM are stored in SCOBOT.  Further API's can be made available to interact with them below.</p><p>Do not confuse the fact that by making a call to SCORM your some how invoking a round trip to the server.  "Commit", will invoke a server communication howerver.</p>
				<h4>SB.suspend();</h4>
				<p><b>This is a Terminating Call</b></p>
				<p>There are a couple places <code>suspend</code> could be triggered.  The Browser fires a onunload/onbeforeunload which is caught up above in the events.js file.  Or a button like "Save/Exit/Quit" is exposed in your content allowing a student to return to it later.  This is a <u>terminating</u> call, and once terminated the LMS will no longer accept further input from the content.  The player <u>must</u> manage disabling of field entry as not to give the learner the appearance that they can still work.  Some LMS's will actually return you to a prior screen or menu when <code>Terminate();</code> is triggered.</p>
				<ol class="numlist whitegrad rounded">
					<li><code>scorm.setvalue('cmi.success_status', 'unknown');  // Learners Success Status: unknown * will only do this if their performance wasn't set prior.</code></li>
					<li><code>scorm.setvalue('cmi.exit', 'suspend');             // Learners Exit type suspend</code></li>
					<li><code>scorm.setvalue('cmi.completion_status', 'incomplete'); // Learners Completion Status: incomplete * only if the status wasn't set prior.</code></li>
				</ol>
				<br />
				<h4>SB.finish();</h4>
				<p><b>This is a Terminating Call</b></p>
				<p>Finish is like suspending except were actually "done" with this SCO.  [Need to lookup parameters that dictate review mode or behaviors for how this behaves].  Completion Status will be set to complete.</p>
				<ol class="numlist whitegrad rounded">
					<li><code>scorm.setvalue('cmi.success_status', 'unknown');  // Learners Success Status: DEFAULT_SUCCESS_STATUS * will only do this if their performance wasn't set prior.</code></li>
					<li><code>scorm.setvalue('cmi.exit', 'normal');             // Learners Exit type normal</code></li>
					<li><code>scorm.setvalue('cmi.completion_status', 'completed'); // Learners Completion Status: completed</code></li>
				</ol>
				<br />
				<h4>SB.timeout();</h4>
				<p><b>This is a Terminating Call</b></p>
				<p>Timeout is like suspending or finishing except were actually "done" with this SCO due to a timeout (timer).  Completion Status will be set to complete.</p>
				<ol class="numlist whitegrad rounded">
					<li><code>scorm.setvalue('cmi.success_status', 'unknown');  // Learners Success Status: DEFAULT_SUCCESS_STATUS * will only do this if their performance wasn't set prior.</code></li>
					<li><code>scorm.setvalue('cmi.exit', 'timeout');             // Learners Exit type timeout</code></li>
					<li><code>scorm.setvalue('cmi.completion_status', 'completed'); // Learners Completion Status: completed</code></li>
				</ol>
				<br />

			</div>
			</div>
		</div>
	</body>
</html>